// Jenkinsfile 構文リファレンス
// https://www.jenkins.io/doc/book/pipeline/syntax/
pipeline {
  // デフォルトで実行するエージェント
  agent {
    label 'master'
  }
  // ジョブで使用する環境変数を定義
  // NOTE: これらに加えて下記の環境変数も使用できる
  // * Jenkins が定義している情報環境変数（ビルド番号など）
  //   * https://www.jenkins.io/doc/book/pipeline/jenkinsfile/#using-environment-variables
  // * Jenkins の設定で任意に定義したグローバル環境変数
  // * ジョブの実行環境に定義された環境変数
  // NOTE: 資格情報（秘密変数）は credentials を使用して明示的に指定しないと使用できない
  // シェルスクリプトで "printenv" コマンドを使用することで全環境変数の確認が可能
  environment {
    // Chatwork 通知用トークン（資格情報）
    CHATWORK_TOKEN = credentials 'chatwork-token'
  }
  // ジョブのフロー
  // ステージごとに直列実行され、途中でステージが失敗するとジョブ全体が失敗扱いになる
  stages {
    // ジョブ開始前処理
    stage('Pre') {
      parallel {
        // ジョブ開始の通知を Chatwork に行う
        stage('Notify') {
          steps {
            sh '.ci/chatwork/notify.sh start'
          }
        }
        // 古いジョブが起動中の場合は中断させる
        stage('Job Check') {
          steps {
            script {
              // Groovy Script（ファイル最下部参照）
              cancelPreviousBuilds()
            }
          }
        }
      }
    }
    // 静的解析を行う
    stage('Lint') {
      parallel {
        /**
         * .editorconfig に沿ったフォーマットかチェックする
         * https://github.com/editorconfig-checker/editorconfig-checker
         */
        stage('editorconfig-checker') {
          agent {
            docker 'mstruebing/editorconfig-checker:2.1.0'
          }
          steps {
            // エラー時に警告マークにする（ジョブは続けさせる）
            warnError('Script failed!') {
              // 除外ファイルや設定は .ci/editorconfig-checker.json に記載
              sh 'ec --config .ci/editorconfig-checker.json'
            }
          }
        }
      }
    }
    // CMake のビルドテストを行う
    // 三大コンパイラの最新？バージョンで行う
    // Rendering はプラットフォーム依存のためビルドから除外する
    stage('Test') {
      parallel {
        stage('GCC') {
          agent {
            dockerfile {
              dir '.ci/test/gcc'
              additionalBuildArgs '--pull'
            }
          }
          steps {
            sh '.ci/test/gcc/info.sh'
            sh '.ci/test/modify_cmakelists.sh'
            sh '.ci/test/gcc/build.sh'
          }
        }
        stage('Clang') {
          agent {
            label 'macos'
          }
          steps {
            sh '.ci/test/clang/info.sh'
            sh '.ci/test/modify_cmakelists.sh'
            sh '.ci/test/clang/build.sh'
          }
        }
        stage('VC++') {
          agent {
            label 'windows'
          }
          steps {
            bat '.ci/test/vc++/info.bat'
            sh '.ci/test/modify_cmakelists.sh'
            bat '.ci/test/vc++/build.bat'
          }
        }
      }
    }
  }
  // ジョブの最後に行う処理
  // CI の結果を Chatwork に通知する
  // スクリプトの引数にステータスを渡す
  post {
    // 全ジョブの成功時
    success {
      sh '.ci/chatwork/notify.sh success'
    }
    // ジョブに不安定状態のステージがある場合
    unstable {
      sh '.ci/chatwork/notify.sh unstable'
    }
    // ジョブの失敗時
    failure {
      sh '.ci/chatwork/notify.sh failure'
    }
    // ジョブが中断された時
    aborted {
      sh '.ci/chatwork/notify.sh aborted'
    }
  }
}
/**
 * 古いジョブをキャンセルするための Groovy メソッド
 * https://medium.com/@vedranvucetic/run-only-last-triggered-job-for-branch-in-descriptive-jenkins-pipeline-a07bb84ae075
 */
@NonCPS
final cancelPreviousBuilds() {
  final jobName = env.JOB_NAME
  final buildNumber = env.BUILD_NUMBER.toInteger()
  // 現在のジョブ（グループ名/リポ名/ブランチ・リクエスト名）を取得
  final currentJob = Jenkins.get().getItemByFullName(jobName)
  // ジョブのビルドを走査
  for (final build : currentJob.builds) {
    // ジョブの本体を取得
    final exec = build.getExecutor()
    if (exec == null) {
      continue
    }
    // 現在のジョブより古いジョブが実行中の場合は中断させる
    if (build.isBuilding() && build.number.toInteger() < buildNumber) {
      exec.interrupt(
        Result.ABORTED,
        new CauseOfInterruption.UserInterruption("Aborted by #${build.number}")
      )
      println("Aborted previously running build #${build.number}")
    }
  }
}
